#! /usr/bin/env ruby

require 'optparse'
require 'pry'

lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'csvsql'

options = { csv_path: [] }
OptionParser.new do |opts|
  opts.banner = "Csvsql #{Csvsql::VERSION}\nUsage: csvsql [options] SQL"
  opts.version = Csvsql::VERSION

  opts.on('-i', '--input path', "CSV file path, optional. read from stdin if no give") do |path|
    options[:csv_path] << path
  end

  opts.on('-c', '--use-cache', "Cache data in ~/.csvsql_cache. it will still reload if file was changed") do
    options[:use_cache] = true
  end

  opts.on(
    '-b', '--batch-rows n',
    "How many rows to import per batch. Default value is #{Csvsql::Db::BATCH_ROWS}"
  ) do |n|
    options[:batch_rows] = n.to_i
  end

  opts.on('-e', '--encoding encoding', "Set the file encoding, default is UTF-8") do |encoding|
    options[:encoding] = encoding
  end

  opts.on('--clear-cache', "Clear all cache data") do
    options[:clear_cache] = true
  end

  opts.on('--debug', "Print debug info") do
    options[:debug] = true
  end
end.parse!

if options[:clear_cache]
  Csvsql::Db.clear_cache!
  puts "Completed clear cache."
  exit 0
end

if options[:debug]
  Csvsql::Tracker.tracker = Csvsql::Tracker.new(Logger.new($stdout))
end

csv_data = case options[:csv_path].size
when 0
  StringIO.new($stdin.read)
when 1
  options[:csv_path].first
else
  options[:csv_path].each_with_object({}) do |path, r|
    p, n = path.split(':')
    if n.nil? || n.empty?
      puts "You should give #{p} a name, example: #{p}:a_name"
      exit 1
    end
    r[n] = p
  end
end

puts Csvsql.execute(
  ARGV[0], csv_data,
  use_cache: options[:use_cache],
  batch_rows: options[:batch_rows],
  sql_error_action: 'exit',
  encoding: options[:encoding]
)
